import { HttpRequest as __HttpRequest } from "@aws-sdk/protocol-http";
import { decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectInt32 as __expectInt32, expectLong as __expectLong, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectObject as __expectObject, expectString as __expectString, limitedParseDouble as __limitedParseDouble, map as __map, parseEpochTimestamp as __parseEpochTimestamp, resolvedPath as __resolvedPath, throwDefaultError, } from "@aws-sdk/smithy-client";
import { ElasticsearchServiceServiceException as __BaseException } from "../models/ElasticsearchServiceServiceException";
import { AccessDeniedException, BaseException, ConflictException, DisabledOperationException, InternalException, InvalidPaginationTokenException, InvalidTypeException, LimitExceededException, ResourceAlreadyExistsException, ResourceNotFoundException, ValidationException, } from "../models/models_0";
export const serializeAws_restJson1AcceptInboundCrossClusterSearchConnectionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2015-01-01/es/ccs/inboundConnection/{CrossClusterSearchConnectionId}/accept";
    resolvedPath = __resolvedPath(resolvedPath, input, "CrossClusterSearchConnectionId", () => input.CrossClusterSearchConnectionId, "{CrossClusterSearchConnectionId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1AddTagsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2015-01-01/tags";
    let body;
    body = JSON.stringify({
        ...(input.ARN != null && { ARN: input.ARN }),
        ...(input.TagList != null && { TagList: serializeAws_restJson1TagList(input.TagList, context) }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1AssociatePackageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2015-01-01/packages/associate/{PackageID}/{DomainName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "PackageID", () => input.PackageID, "{PackageID}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1AuthorizeVpcEndpointAccessCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2015-01-01/es/domain/{DomainName}/authorizeVpcEndpointAccess";
    resolvedPath = __resolvedPath(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify({
        ...(input.Account != null && { Account: input.Account }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CancelElasticsearchServiceSoftwareUpdateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2015-01-01/es/serviceSoftwareUpdate/cancel";
    let body;
    body = JSON.stringify({
        ...(input.DomainName != null && { DomainName: input.DomainName }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CreateElasticsearchDomainCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2015-01-01/es/domain";
    let body;
    body = JSON.stringify({
        ...(input.AccessPolicies != null && { AccessPolicies: input.AccessPolicies }),
        ...(input.AdvancedOptions != null && {
            AdvancedOptions: serializeAws_restJson1AdvancedOptions(input.AdvancedOptions, context),
        }),
        ...(input.AdvancedSecurityOptions != null && {
            AdvancedSecurityOptions: serializeAws_restJson1AdvancedSecurityOptionsInput(input.AdvancedSecurityOptions, context),
        }),
        ...(input.AutoTuneOptions != null && {
            AutoTuneOptions: serializeAws_restJson1AutoTuneOptionsInput(input.AutoTuneOptions, context),
        }),
        ...(input.CognitoOptions != null && {
            CognitoOptions: serializeAws_restJson1CognitoOptions(input.CognitoOptions, context),
        }),
        ...(input.DomainEndpointOptions != null && {
            DomainEndpointOptions: serializeAws_restJson1DomainEndpointOptions(input.DomainEndpointOptions, context),
        }),
        ...(input.DomainName != null && { DomainName: input.DomainName }),
        ...(input.EBSOptions != null && { EBSOptions: serializeAws_restJson1EBSOptions(input.EBSOptions, context) }),
        ...(input.ElasticsearchClusterConfig != null && {
            ElasticsearchClusterConfig: serializeAws_restJson1ElasticsearchClusterConfig(input.ElasticsearchClusterConfig, context),
        }),
        ...(input.ElasticsearchVersion != null && { ElasticsearchVersion: input.ElasticsearchVersion }),
        ...(input.EncryptionAtRestOptions != null && {
            EncryptionAtRestOptions: serializeAws_restJson1EncryptionAtRestOptions(input.EncryptionAtRestOptions, context),
        }),
        ...(input.LogPublishingOptions != null && {
            LogPublishingOptions: serializeAws_restJson1LogPublishingOptions(input.LogPublishingOptions, context),
        }),
        ...(input.NodeToNodeEncryptionOptions != null && {
            NodeToNodeEncryptionOptions: serializeAws_restJson1NodeToNodeEncryptionOptions(input.NodeToNodeEncryptionOptions, context),
        }),
        ...(input.SnapshotOptions != null && {
            SnapshotOptions: serializeAws_restJson1SnapshotOptions(input.SnapshotOptions, context),
        }),
        ...(input.TagList != null && { TagList: serializeAws_restJson1TagList(input.TagList, context) }),
        ...(input.VPCOptions != null && { VPCOptions: serializeAws_restJson1VPCOptions(input.VPCOptions, context) }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CreateOutboundCrossClusterSearchConnectionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2015-01-01/es/ccs/outboundConnection";
    let body;
    body = JSON.stringify({
        ...(input.ConnectionAlias != null && { ConnectionAlias: input.ConnectionAlias }),
        ...(input.DestinationDomainInfo != null && {
            DestinationDomainInfo: serializeAws_restJson1DomainInformation(input.DestinationDomainInfo, context),
        }),
        ...(input.SourceDomainInfo != null && {
            SourceDomainInfo: serializeAws_restJson1DomainInformation(input.SourceDomainInfo, context),
        }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CreatePackageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2015-01-01/packages";
    let body;
    body = JSON.stringify({
        ...(input.PackageDescription != null && { PackageDescription: input.PackageDescription }),
        ...(input.PackageName != null && { PackageName: input.PackageName }),
        ...(input.PackageSource != null && {
            PackageSource: serializeAws_restJson1PackageSource(input.PackageSource, context),
        }),
        ...(input.PackageType != null && { PackageType: input.PackageType }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1CreateVpcEndpointCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2015-01-01/es/vpcEndpoints";
    let body;
    body = JSON.stringify({
        ...(input.ClientToken != null && { ClientToken: input.ClientToken }),
        ...(input.DomainArn != null && { DomainArn: input.DomainArn }),
        ...(input.VpcOptions != null && { VpcOptions: serializeAws_restJson1VPCOptions(input.VpcOptions, context) }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DeleteElasticsearchDomainCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2015-01-01/es/domain/{DomainName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DeleteElasticsearchServiceRoleCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2015-01-01/es/role";
    let body;
    body = "";
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DeleteInboundCrossClusterSearchConnectionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2015-01-01/es/ccs/inboundConnection/{CrossClusterSearchConnectionId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "CrossClusterSearchConnectionId", () => input.CrossClusterSearchConnectionId, "{CrossClusterSearchConnectionId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DeleteOutboundCrossClusterSearchConnectionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2015-01-01/es/ccs/outboundConnection/{CrossClusterSearchConnectionId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "CrossClusterSearchConnectionId", () => input.CrossClusterSearchConnectionId, "{CrossClusterSearchConnectionId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DeletePackageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2015-01-01/packages/{PackageID}";
    resolvedPath = __resolvedPath(resolvedPath, input, "PackageID", () => input.PackageID, "{PackageID}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DeleteVpcEndpointCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2015-01-01/es/vpcEndpoints/{VpcEndpointId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "VpcEndpointId", () => input.VpcEndpointId, "{VpcEndpointId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeDomainAutoTunesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2015-01-01/es/domain/{DomainName}/autoTunes";
    resolvedPath = __resolvedPath(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify({
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeDomainChangeProgressCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2015-01-01/es/domain/{DomainName}/progress";
    resolvedPath = __resolvedPath(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    const query = map({
        changeid: [, input.ChangeId],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1DescribeElasticsearchDomainCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2015-01-01/es/domain/{DomainName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeElasticsearchDomainConfigCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2015-01-01/es/domain/{DomainName}/config";
    resolvedPath = __resolvedPath(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeElasticsearchDomainsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2015-01-01/es/domain-info";
    let body;
    body = JSON.stringify({
        ...(input.DomainNames != null && { DomainNames: serializeAws_restJson1DomainNameList(input.DomainNames, context) }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeElasticsearchInstanceTypeLimitsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2015-01-01/es/instanceTypeLimits/{ElasticsearchVersion}/{InstanceType}";
    resolvedPath = __resolvedPath(resolvedPath, input, "InstanceType", () => input.InstanceType, "{InstanceType}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "ElasticsearchVersion", () => input.ElasticsearchVersion, "{ElasticsearchVersion}", false);
    const query = map({
        domainName: [, input.DomainName],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1DescribeInboundCrossClusterSearchConnectionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2015-01-01/es/ccs/inboundConnection/search";
    let body;
    body = JSON.stringify({
        ...(input.Filters != null && { Filters: serializeAws_restJson1FilterList(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeOutboundCrossClusterSearchConnectionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2015-01-01/es/ccs/outboundConnection/search";
    let body;
    body = JSON.stringify({
        ...(input.Filters != null && { Filters: serializeAws_restJson1FilterList(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribePackagesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2015-01-01/packages/describe";
    let body;
    body = JSON.stringify({
        ...(input.Filters != null && { Filters: serializeAws_restJson1DescribePackagesFilterList(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DescribeReservedElasticsearchInstanceOfferingsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2015-01-01/es/reservedInstanceOfferings";
    const query = map({
        offeringId: [, input.ReservedElasticsearchInstanceOfferingId],
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1DescribeReservedElasticsearchInstancesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2015-01-01/es/reservedInstances";
    const query = map({
        reservationId: [, input.ReservedElasticsearchInstanceId],
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1DescribeVpcEndpointsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2015-01-01/es/vpcEndpoints/describe";
    let body;
    body = JSON.stringify({
        ...(input.VpcEndpointIds != null && {
            VpcEndpointIds: serializeAws_restJson1VpcEndpointIdList(input.VpcEndpointIds, context),
        }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1DissociatePackageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2015-01-01/packages/dissociate/{PackageID}/{DomainName}";
    resolvedPath = __resolvedPath(resolvedPath, input, "PackageID", () => input.PackageID, "{PackageID}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1GetCompatibleElasticsearchVersionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2015-01-01/es/compatibleVersions";
    const query = map({
        domainName: [, input.DomainName],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1GetPackageVersionHistoryCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2015-01-01/packages/{PackageID}/history";
    resolvedPath = __resolvedPath(resolvedPath, input, "PackageID", () => input.PackageID, "{PackageID}", false);
    const query = map({
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1GetUpgradeHistoryCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2015-01-01/es/upgradeDomain/{DomainName}/history";
    resolvedPath = __resolvedPath(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    const query = map({
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1GetUpgradeStatusCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2015-01-01/es/upgradeDomain/{DomainName}/status";
    resolvedPath = __resolvedPath(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1ListDomainNamesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2015-01-01/domain";
    const query = map({
        engineType: [, input.EngineType],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListDomainsForPackageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2015-01-01/packages/{PackageID}/domains";
    resolvedPath = __resolvedPath(resolvedPath, input, "PackageID", () => input.PackageID, "{PackageID}", false);
    const query = map({
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListElasticsearchInstanceTypesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2015-01-01/es/instanceTypes/{ElasticsearchVersion}";
    resolvedPath = __resolvedPath(resolvedPath, input, "ElasticsearchVersion", () => input.ElasticsearchVersion, "{ElasticsearchVersion}", false);
    const query = map({
        domainName: [, input.DomainName],
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListElasticsearchVersionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2015-01-01/es/versions";
    const query = map({
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListPackagesForDomainCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2015-01-01/domain/{DomainName}/packages";
    resolvedPath = __resolvedPath(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    const query = map({
        maxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListTagsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2015-01-01/tags";
    const query = map({
        arn: [, __expectNonNull(input.ARN, `ARN`)],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListVpcEndpointAccessCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2015-01-01/es/domain/{DomainName}/listVpcEndpointAccess";
    resolvedPath = __resolvedPath(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    const query = map({
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListVpcEndpointsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2015-01-01/es/vpcEndpoints";
    const query = map({
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1ListVpcEndpointsForDomainCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2015-01-01/es/domain/{DomainName}/vpcEndpoints";
    resolvedPath = __resolvedPath(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    const query = map({
        nextToken: [, input.NextToken],
    });
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
export const serializeAws_restJson1PurchaseReservedElasticsearchInstanceOfferingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2015-01-01/es/purchaseReservedInstanceOffering";
    let body;
    body = JSON.stringify({
        ...(input.InstanceCount != null && { InstanceCount: input.InstanceCount }),
        ...(input.ReservationName != null && { ReservationName: input.ReservationName }),
        ...(input.ReservedElasticsearchInstanceOfferingId != null && {
            ReservedElasticsearchInstanceOfferingId: input.ReservedElasticsearchInstanceOfferingId,
        }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1RejectInboundCrossClusterSearchConnectionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2015-01-01/es/ccs/inboundConnection/{CrossClusterSearchConnectionId}/reject";
    resolvedPath = __resolvedPath(resolvedPath, input, "CrossClusterSearchConnectionId", () => input.CrossClusterSearchConnectionId, "{CrossClusterSearchConnectionId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1RemoveTagsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2015-01-01/tags-removal";
    let body;
    body = JSON.stringify({
        ...(input.ARN != null && { ARN: input.ARN }),
        ...(input.TagKeys != null && { TagKeys: serializeAws_restJson1StringList(input.TagKeys, context) }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1RevokeVpcEndpointAccessCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2015-01-01/es/domain/{DomainName}/revokeVpcEndpointAccess";
    resolvedPath = __resolvedPath(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify({
        ...(input.Account != null && { Account: input.Account }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1StartElasticsearchServiceSoftwareUpdateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/2015-01-01/es/serviceSoftwareUpdate/start";
    let body;
    body = JSON.stringify({
        ...(input.DomainName != null && { DomainName: input.DomainName }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1UpdateElasticsearchDomainConfigCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2015-01-01/es/domain/{DomainName}/config";
    resolvedPath = __resolvedPath(resolvedPath, input, "DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify({
        ...(input.AccessPolicies != null && { AccessPolicies: input.AccessPolicies }),
        ...(input.AdvancedOptions != null && {
            AdvancedOptions: serializeAws_restJson1AdvancedOptions(input.AdvancedOptions, context),
        }),
        ...(input.AdvancedSecurityOptions != null && {
            AdvancedSecurityOptions: serializeAws_restJson1AdvancedSecurityOptionsInput(input.AdvancedSecurityOptions, context),
        }),
        ...(input.AutoTuneOptions != null && {
            AutoTuneOptions: serializeAws_restJson1AutoTuneOptions(input.AutoTuneOptions, context),
        }),
        ...(input.CognitoOptions != null && {
            CognitoOptions: serializeAws_restJson1CognitoOptions(input.CognitoOptions, context),
        }),
        ...(input.DomainEndpointOptions != null && {
            DomainEndpointOptions: serializeAws_restJson1DomainEndpointOptions(input.DomainEndpointOptions, context),
        }),
        ...(input.DryRun != null && { DryRun: input.DryRun }),
        ...(input.EBSOptions != null && { EBSOptions: serializeAws_restJson1EBSOptions(input.EBSOptions, context) }),
        ...(input.ElasticsearchClusterConfig != null && {
            ElasticsearchClusterConfig: serializeAws_restJson1ElasticsearchClusterConfig(input.ElasticsearchClusterConfig, context),
        }),
        ...(input.EncryptionAtRestOptions != null && {
            EncryptionAtRestOptions: serializeAws_restJson1EncryptionAtRestOptions(input.EncryptionAtRestOptions, context),
        }),
        ...(input.LogPublishingOptions != null && {
            LogPublishingOptions: serializeAws_restJson1LogPublishingOptions(input.LogPublishingOptions, context),
        }),
        ...(input.NodeToNodeEncryptionOptions != null && {
            NodeToNodeEncryptionOptions: serializeAws_restJson1NodeToNodeEncryptionOptions(input.NodeToNodeEncryptionOptions, context),
        }),
        ...(input.SnapshotOptions != null && {
            SnapshotOptions: serializeAws_restJson1SnapshotOptions(input.SnapshotOptions, context),
        }),
        ...(input.VPCOptions != null && { VPCOptions: serializeAws_restJson1VPCOptions(input.VPCOptions, context) }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1UpdatePackageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2015-01-01/packages/update";
    let body;
    body = JSON.stringify({
        ...(input.CommitMessage != null && { CommitMessage: input.CommitMessage }),
        ...(input.PackageDescription != null && { PackageDescription: input.PackageDescription }),
        ...(input.PackageID != null && { PackageID: input.PackageID }),
        ...(input.PackageSource != null && {
            PackageSource: serializeAws_restJson1PackageSource(input.PackageSource, context),
        }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1UpdateVpcEndpointCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2015-01-01/es/vpcEndpoints/update";
    let body;
    body = JSON.stringify({
        ...(input.VpcEndpointId != null && { VpcEndpointId: input.VpcEndpointId }),
        ...(input.VpcOptions != null && { VpcOptions: serializeAws_restJson1VPCOptions(input.VpcOptions, context) }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const serializeAws_restJson1UpgradeElasticsearchDomainCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/2015-01-01/es/upgradeDomain";
    let body;
    body = JSON.stringify({
        ...(input.DomainName != null && { DomainName: input.DomainName }),
        ...(input.PerformCheckOnly != null && { PerformCheckOnly: input.PerformCheckOnly }),
        ...(input.TargetVersion != null && { TargetVersion: input.TargetVersion }),
    });
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const deserializeAws_restJson1AcceptInboundCrossClusterSearchConnectionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1AcceptInboundCrossClusterSearchConnectionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.CrossClusterSearchConnection != null) {
        contents.CrossClusterSearchConnection = deserializeAws_restJson1InboundCrossClusterSearchConnection(data.CrossClusterSearchConnection, context);
    }
    return contents;
};
const deserializeAws_restJson1AcceptInboundCrossClusterSearchConnectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DisabledOperationException":
        case "com.amazonaws.elasticsearchservice#DisabledOperationException":
            throw await deserializeAws_restJson1DisabledOperationExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.elasticsearchservice#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1AddTagsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1AddTagsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1AddTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.elasticsearchservice#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1AssociatePackageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1AssociatePackageCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.DomainPackageDetails != null) {
        contents.DomainPackageDetails = deserializeAws_restJson1DomainPackageDetails(data.DomainPackageDetails, context);
    }
    return contents;
};
const deserializeAws_restJson1AssociatePackageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.elasticsearchservice#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.elasticsearchservice#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1AuthorizeVpcEndpointAccessCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1AuthorizeVpcEndpointAccessCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.AuthorizedPrincipal != null) {
        contents.AuthorizedPrincipal = deserializeAws_restJson1AuthorizedPrincipal(data.AuthorizedPrincipal, context);
    }
    return contents;
};
const deserializeAws_restJson1AuthorizeVpcEndpointAccessCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "DisabledOperationException":
        case "com.amazonaws.elasticsearchservice#DisabledOperationException":
            throw await deserializeAws_restJson1DisabledOperationExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.elasticsearchservice#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CancelElasticsearchServiceSoftwareUpdateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CancelElasticsearchServiceSoftwareUpdateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.ServiceSoftwareOptions != null) {
        contents.ServiceSoftwareOptions = deserializeAws_restJson1ServiceSoftwareOptions(data.ServiceSoftwareOptions, context);
    }
    return contents;
};
const deserializeAws_restJson1CancelElasticsearchServiceSoftwareUpdateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreateElasticsearchDomainCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateElasticsearchDomainCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.DomainStatus != null) {
        contents.DomainStatus = deserializeAws_restJson1ElasticsearchDomainStatus(data.DomainStatus, context);
    }
    return contents;
};
const deserializeAws_restJson1CreateElasticsearchDomainCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "DisabledOperationException":
        case "com.amazonaws.elasticsearchservice#DisabledOperationException":
            throw await deserializeAws_restJson1DisabledOperationExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "InvalidTypeException":
        case "com.amazonaws.elasticsearchservice#InvalidTypeException":
            throw await deserializeAws_restJson1InvalidTypeExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.elasticsearchservice#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.elasticsearchservice#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreateOutboundCrossClusterSearchConnectionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateOutboundCrossClusterSearchConnectionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.ConnectionAlias != null) {
        contents.ConnectionAlias = __expectString(data.ConnectionAlias);
    }
    if (data.ConnectionStatus != null) {
        contents.ConnectionStatus = deserializeAws_restJson1OutboundCrossClusterSearchConnectionStatus(data.ConnectionStatus, context);
    }
    if (data.CrossClusterSearchConnectionId != null) {
        contents.CrossClusterSearchConnectionId = __expectString(data.CrossClusterSearchConnectionId);
    }
    if (data.DestinationDomainInfo != null) {
        contents.DestinationDomainInfo = deserializeAws_restJson1DomainInformation(data.DestinationDomainInfo, context);
    }
    if (data.SourceDomainInfo != null) {
        contents.SourceDomainInfo = deserializeAws_restJson1DomainInformation(data.SourceDomainInfo, context);
    }
    return contents;
};
const deserializeAws_restJson1CreateOutboundCrossClusterSearchConnectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DisabledOperationException":
        case "com.amazonaws.elasticsearchservice#DisabledOperationException":
            throw await deserializeAws_restJson1DisabledOperationExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.elasticsearchservice#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.elasticsearchservice#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreatePackageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreatePackageCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.PackageDetails != null) {
        contents.PackageDetails = deserializeAws_restJson1PackageDetails(data.PackageDetails, context);
    }
    return contents;
};
const deserializeAws_restJson1CreatePackageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.elasticsearchservice#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "InvalidTypeException":
        case "com.amazonaws.elasticsearchservice#InvalidTypeException":
            throw await deserializeAws_restJson1InvalidTypeExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.elasticsearchservice#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.elasticsearchservice#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1CreateVpcEndpointCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateVpcEndpointCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.VpcEndpoint != null) {
        contents.VpcEndpoint = deserializeAws_restJson1VpcEndpoint(data.VpcEndpoint, context);
    }
    return contents;
};
const deserializeAws_restJson1CreateVpcEndpointCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.elasticsearchservice#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "DisabledOperationException":
        case "com.amazonaws.elasticsearchservice#DisabledOperationException":
            throw await deserializeAws_restJson1DisabledOperationExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.elasticsearchservice#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteElasticsearchDomainCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteElasticsearchDomainCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.DomainStatus != null) {
        contents.DomainStatus = deserializeAws_restJson1ElasticsearchDomainStatus(data.DomainStatus, context);
    }
    return contents;
};
const deserializeAws_restJson1DeleteElasticsearchDomainCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteElasticsearchServiceRoleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteElasticsearchServiceRoleCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1DeleteElasticsearchServiceRoleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteInboundCrossClusterSearchConnectionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteInboundCrossClusterSearchConnectionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.CrossClusterSearchConnection != null) {
        contents.CrossClusterSearchConnection = deserializeAws_restJson1InboundCrossClusterSearchConnection(data.CrossClusterSearchConnection, context);
    }
    return contents;
};
const deserializeAws_restJson1DeleteInboundCrossClusterSearchConnectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DisabledOperationException":
        case "com.amazonaws.elasticsearchservice#DisabledOperationException":
            throw await deserializeAws_restJson1DisabledOperationExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteOutboundCrossClusterSearchConnectionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteOutboundCrossClusterSearchConnectionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.CrossClusterSearchConnection != null) {
        contents.CrossClusterSearchConnection = deserializeAws_restJson1OutboundCrossClusterSearchConnection(data.CrossClusterSearchConnection, context);
    }
    return contents;
};
const deserializeAws_restJson1DeleteOutboundCrossClusterSearchConnectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DisabledOperationException":
        case "com.amazonaws.elasticsearchservice#DisabledOperationException":
            throw await deserializeAws_restJson1DisabledOperationExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeletePackageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeletePackageCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.PackageDetails != null) {
        contents.PackageDetails = deserializeAws_restJson1PackageDetails(data.PackageDetails, context);
    }
    return contents;
};
const deserializeAws_restJson1DeletePackageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.elasticsearchservice#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.elasticsearchservice#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DeleteVpcEndpointCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteVpcEndpointCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.VpcEndpointSummary != null) {
        contents.VpcEndpointSummary = deserializeAws_restJson1VpcEndpointSummary(data.VpcEndpointSummary, context);
    }
    return contents;
};
const deserializeAws_restJson1DeleteVpcEndpointCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "DisabledOperationException":
        case "com.amazonaws.elasticsearchservice#DisabledOperationException":
            throw await deserializeAws_restJson1DisabledOperationExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeDomainAutoTunesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeDomainAutoTunesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.AutoTunes != null) {
        contents.AutoTunes = deserializeAws_restJson1AutoTuneList(data.AutoTunes, context);
    }
    if (data.NextToken != null) {
        contents.NextToken = __expectString(data.NextToken);
    }
    return contents;
};
const deserializeAws_restJson1DescribeDomainAutoTunesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeDomainChangeProgressCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeDomainChangeProgressCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.ChangeProgressStatus != null) {
        contents.ChangeProgressStatus = deserializeAws_restJson1ChangeProgressStatusDetails(data.ChangeProgressStatus, context);
    }
    return contents;
};
const deserializeAws_restJson1DescribeDomainChangeProgressCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeElasticsearchDomainCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeElasticsearchDomainCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.DomainStatus != null) {
        contents.DomainStatus = deserializeAws_restJson1ElasticsearchDomainStatus(data.DomainStatus, context);
    }
    return contents;
};
const deserializeAws_restJson1DescribeElasticsearchDomainCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeElasticsearchDomainConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeElasticsearchDomainConfigCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.DomainConfig != null) {
        contents.DomainConfig = deserializeAws_restJson1ElasticsearchDomainConfig(data.DomainConfig, context);
    }
    return contents;
};
const deserializeAws_restJson1DescribeElasticsearchDomainConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeElasticsearchDomainsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeElasticsearchDomainsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.DomainStatusList != null) {
        contents.DomainStatusList = deserializeAws_restJson1ElasticsearchDomainStatusList(data.DomainStatusList, context);
    }
    return contents;
};
const deserializeAws_restJson1DescribeElasticsearchDomainsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeElasticsearchInstanceTypeLimitsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeElasticsearchInstanceTypeLimitsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.LimitsByRole != null) {
        contents.LimitsByRole = deserializeAws_restJson1LimitsByRole(data.LimitsByRole, context);
    }
    return contents;
};
const deserializeAws_restJson1DescribeElasticsearchInstanceTypeLimitsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "InvalidTypeException":
        case "com.amazonaws.elasticsearchservice#InvalidTypeException":
            throw await deserializeAws_restJson1InvalidTypeExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.elasticsearchservice#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeInboundCrossClusterSearchConnectionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeInboundCrossClusterSearchConnectionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.CrossClusterSearchConnections != null) {
        contents.CrossClusterSearchConnections = deserializeAws_restJson1InboundCrossClusterSearchConnections(data.CrossClusterSearchConnections, context);
    }
    if (data.NextToken != null) {
        contents.NextToken = __expectString(data.NextToken);
    }
    return contents;
};
const deserializeAws_restJson1DescribeInboundCrossClusterSearchConnectionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DisabledOperationException":
        case "com.amazonaws.elasticsearchservice#DisabledOperationException":
            throw await deserializeAws_restJson1DisabledOperationExceptionResponse(parsedOutput, context);
        case "InvalidPaginationTokenException":
        case "com.amazonaws.elasticsearchservice#InvalidPaginationTokenException":
            throw await deserializeAws_restJson1InvalidPaginationTokenExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeOutboundCrossClusterSearchConnectionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeOutboundCrossClusterSearchConnectionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.CrossClusterSearchConnections != null) {
        contents.CrossClusterSearchConnections = deserializeAws_restJson1OutboundCrossClusterSearchConnections(data.CrossClusterSearchConnections, context);
    }
    if (data.NextToken != null) {
        contents.NextToken = __expectString(data.NextToken);
    }
    return contents;
};
const deserializeAws_restJson1DescribeOutboundCrossClusterSearchConnectionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DisabledOperationException":
        case "com.amazonaws.elasticsearchservice#DisabledOperationException":
            throw await deserializeAws_restJson1DisabledOperationExceptionResponse(parsedOutput, context);
        case "InvalidPaginationTokenException":
        case "com.amazonaws.elasticsearchservice#InvalidPaginationTokenException":
            throw await deserializeAws_restJson1InvalidPaginationTokenExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribePackagesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribePackagesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.NextToken != null) {
        contents.NextToken = __expectString(data.NextToken);
    }
    if (data.PackageDetailsList != null) {
        contents.PackageDetailsList = deserializeAws_restJson1PackageDetailsList(data.PackageDetailsList, context);
    }
    return contents;
};
const deserializeAws_restJson1DescribePackagesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.elasticsearchservice#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeReservedElasticsearchInstanceOfferingsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeReservedElasticsearchInstanceOfferingsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.NextToken != null) {
        contents.NextToken = __expectString(data.NextToken);
    }
    if (data.ReservedElasticsearchInstanceOfferings != null) {
        contents.ReservedElasticsearchInstanceOfferings = deserializeAws_restJson1ReservedElasticsearchInstanceOfferingList(data.ReservedElasticsearchInstanceOfferings, context);
    }
    return contents;
};
const deserializeAws_restJson1DescribeReservedElasticsearchInstanceOfferingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DisabledOperationException":
        case "com.amazonaws.elasticsearchservice#DisabledOperationException":
            throw await deserializeAws_restJson1DisabledOperationExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeReservedElasticsearchInstancesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeReservedElasticsearchInstancesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.NextToken != null) {
        contents.NextToken = __expectString(data.NextToken);
    }
    if (data.ReservedElasticsearchInstances != null) {
        contents.ReservedElasticsearchInstances = deserializeAws_restJson1ReservedElasticsearchInstanceList(data.ReservedElasticsearchInstances, context);
    }
    return contents;
};
const deserializeAws_restJson1DescribeReservedElasticsearchInstancesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DisabledOperationException":
        case "com.amazonaws.elasticsearchservice#DisabledOperationException":
            throw await deserializeAws_restJson1DisabledOperationExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DescribeVpcEndpointsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeVpcEndpointsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.VpcEndpointErrors != null) {
        contents.VpcEndpointErrors = deserializeAws_restJson1VpcEndpointErrorList(data.VpcEndpointErrors, context);
    }
    if (data.VpcEndpoints != null) {
        contents.VpcEndpoints = deserializeAws_restJson1VpcEndpoints(data.VpcEndpoints, context);
    }
    return contents;
};
const deserializeAws_restJson1DescribeVpcEndpointsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "DisabledOperationException":
        case "com.amazonaws.elasticsearchservice#DisabledOperationException":
            throw await deserializeAws_restJson1DisabledOperationExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1DissociatePackageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DissociatePackageCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.DomainPackageDetails != null) {
        contents.DomainPackageDetails = deserializeAws_restJson1DomainPackageDetails(data.DomainPackageDetails, context);
    }
    return contents;
};
const deserializeAws_restJson1DissociatePackageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.elasticsearchservice#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.elasticsearchservice#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1GetCompatibleElasticsearchVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetCompatibleElasticsearchVersionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.CompatibleElasticsearchVersions != null) {
        contents.CompatibleElasticsearchVersions = deserializeAws_restJson1CompatibleElasticsearchVersionsList(data.CompatibleElasticsearchVersions, context);
    }
    return contents;
};
const deserializeAws_restJson1GetCompatibleElasticsearchVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "DisabledOperationException":
        case "com.amazonaws.elasticsearchservice#DisabledOperationException":
            throw await deserializeAws_restJson1DisabledOperationExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1GetPackageVersionHistoryCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetPackageVersionHistoryCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.NextToken != null) {
        contents.NextToken = __expectString(data.NextToken);
    }
    if (data.PackageID != null) {
        contents.PackageID = __expectString(data.PackageID);
    }
    if (data.PackageVersionHistoryList != null) {
        contents.PackageVersionHistoryList = deserializeAws_restJson1PackageVersionHistoryList(data.PackageVersionHistoryList, context);
    }
    return contents;
};
const deserializeAws_restJson1GetPackageVersionHistoryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.elasticsearchservice#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1GetUpgradeHistoryCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetUpgradeHistoryCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.NextToken != null) {
        contents.NextToken = __expectString(data.NextToken);
    }
    if (data.UpgradeHistories != null) {
        contents.UpgradeHistories = deserializeAws_restJson1UpgradeHistoryList(data.UpgradeHistories, context);
    }
    return contents;
};
const deserializeAws_restJson1GetUpgradeHistoryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "DisabledOperationException":
        case "com.amazonaws.elasticsearchservice#DisabledOperationException":
            throw await deserializeAws_restJson1DisabledOperationExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1GetUpgradeStatusCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetUpgradeStatusCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.StepStatus != null) {
        contents.StepStatus = __expectString(data.StepStatus);
    }
    if (data.UpgradeName != null) {
        contents.UpgradeName = __expectString(data.UpgradeName);
    }
    if (data.UpgradeStep != null) {
        contents.UpgradeStep = __expectString(data.UpgradeStep);
    }
    return contents;
};
const deserializeAws_restJson1GetUpgradeStatusCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "DisabledOperationException":
        case "com.amazonaws.elasticsearchservice#DisabledOperationException":
            throw await deserializeAws_restJson1DisabledOperationExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListDomainNamesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListDomainNamesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.DomainNames != null) {
        contents.DomainNames = deserializeAws_restJson1DomainInfoList(data.DomainNames, context);
    }
    return contents;
};
const deserializeAws_restJson1ListDomainNamesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListDomainsForPackageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListDomainsForPackageCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.DomainPackageDetailsList != null) {
        contents.DomainPackageDetailsList = deserializeAws_restJson1DomainPackageDetailsList(data.DomainPackageDetailsList, context);
    }
    if (data.NextToken != null) {
        contents.NextToken = __expectString(data.NextToken);
    }
    return contents;
};
const deserializeAws_restJson1ListDomainsForPackageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.elasticsearchservice#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListElasticsearchInstanceTypesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListElasticsearchInstanceTypesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.ElasticsearchInstanceTypes != null) {
        contents.ElasticsearchInstanceTypes = deserializeAws_restJson1ElasticsearchInstanceTypeList(data.ElasticsearchInstanceTypes, context);
    }
    if (data.NextToken != null) {
        contents.NextToken = __expectString(data.NextToken);
    }
    return contents;
};
const deserializeAws_restJson1ListElasticsearchInstanceTypesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListElasticsearchVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListElasticsearchVersionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.ElasticsearchVersions != null) {
        contents.ElasticsearchVersions = deserializeAws_restJson1ElasticsearchVersionList(data.ElasticsearchVersions, context);
    }
    if (data.NextToken != null) {
        contents.NextToken = __expectString(data.NextToken);
    }
    return contents;
};
const deserializeAws_restJson1ListElasticsearchVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListPackagesForDomainCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListPackagesForDomainCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.DomainPackageDetailsList != null) {
        contents.DomainPackageDetailsList = deserializeAws_restJson1DomainPackageDetailsList(data.DomainPackageDetailsList, context);
    }
    if (data.NextToken != null) {
        contents.NextToken = __expectString(data.NextToken);
    }
    return contents;
};
const deserializeAws_restJson1ListPackagesForDomainCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.elasticsearchservice#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListTagsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListTagsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.TagList != null) {
        contents.TagList = deserializeAws_restJson1TagList(data.TagList, context);
    }
    return contents;
};
const deserializeAws_restJson1ListTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListVpcEndpointAccessCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListVpcEndpointAccessCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.AuthorizedPrincipalList != null) {
        contents.AuthorizedPrincipalList = deserializeAws_restJson1AuthorizedPrincipalList(data.AuthorizedPrincipalList, context);
    }
    if (data.NextToken != null) {
        contents.NextToken = __expectString(data.NextToken);
    }
    return contents;
};
const deserializeAws_restJson1ListVpcEndpointAccessCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "DisabledOperationException":
        case "com.amazonaws.elasticsearchservice#DisabledOperationException":
            throw await deserializeAws_restJson1DisabledOperationExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListVpcEndpointsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListVpcEndpointsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.NextToken != null) {
        contents.NextToken = __expectString(data.NextToken);
    }
    if (data.VpcEndpointSummaryList != null) {
        contents.VpcEndpointSummaryList = deserializeAws_restJson1VpcEndpointSummaryList(data.VpcEndpointSummaryList, context);
    }
    return contents;
};
const deserializeAws_restJson1ListVpcEndpointsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "DisabledOperationException":
        case "com.amazonaws.elasticsearchservice#DisabledOperationException":
            throw await deserializeAws_restJson1DisabledOperationExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1ListVpcEndpointsForDomainCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListVpcEndpointsForDomainCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.NextToken != null) {
        contents.NextToken = __expectString(data.NextToken);
    }
    if (data.VpcEndpointSummaryList != null) {
        contents.VpcEndpointSummaryList = deserializeAws_restJson1VpcEndpointSummaryList(data.VpcEndpointSummaryList, context);
    }
    return contents;
};
const deserializeAws_restJson1ListVpcEndpointsForDomainCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "DisabledOperationException":
        case "com.amazonaws.elasticsearchservice#DisabledOperationException":
            throw await deserializeAws_restJson1DisabledOperationExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1PurchaseReservedElasticsearchInstanceOfferingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1PurchaseReservedElasticsearchInstanceOfferingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.ReservationName != null) {
        contents.ReservationName = __expectString(data.ReservationName);
    }
    if (data.ReservedElasticsearchInstanceId != null) {
        contents.ReservedElasticsearchInstanceId = __expectString(data.ReservedElasticsearchInstanceId);
    }
    return contents;
};
const deserializeAws_restJson1PurchaseReservedElasticsearchInstanceOfferingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DisabledOperationException":
        case "com.amazonaws.elasticsearchservice#DisabledOperationException":
            throw await deserializeAws_restJson1DisabledOperationExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.elasticsearchservice#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.elasticsearchservice#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1RejectInboundCrossClusterSearchConnectionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1RejectInboundCrossClusterSearchConnectionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.CrossClusterSearchConnection != null) {
        contents.CrossClusterSearchConnection = deserializeAws_restJson1InboundCrossClusterSearchConnection(data.CrossClusterSearchConnection, context);
    }
    return contents;
};
const deserializeAws_restJson1RejectInboundCrossClusterSearchConnectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DisabledOperationException":
        case "com.amazonaws.elasticsearchservice#DisabledOperationException":
            throw await deserializeAws_restJson1DisabledOperationExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1RemoveTagsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1RemoveTagsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1RemoveTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1RevokeVpcEndpointAccessCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1RevokeVpcEndpointAccessCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const deserializeAws_restJson1RevokeVpcEndpointAccessCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "DisabledOperationException":
        case "com.amazonaws.elasticsearchservice#DisabledOperationException":
            throw await deserializeAws_restJson1DisabledOperationExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1StartElasticsearchServiceSoftwareUpdateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1StartElasticsearchServiceSoftwareUpdateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.ServiceSoftwareOptions != null) {
        contents.ServiceSoftwareOptions = deserializeAws_restJson1ServiceSoftwareOptions(data.ServiceSoftwareOptions, context);
    }
    return contents;
};
const deserializeAws_restJson1StartElasticsearchServiceSoftwareUpdateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1UpdateElasticsearchDomainConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateElasticsearchDomainConfigCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.DomainConfig != null) {
        contents.DomainConfig = deserializeAws_restJson1ElasticsearchDomainConfig(data.DomainConfig, context);
    }
    if (data.DryRunResults != null) {
        contents.DryRunResults = deserializeAws_restJson1DryRunResults(data.DryRunResults, context);
    }
    return contents;
};
const deserializeAws_restJson1UpdateElasticsearchDomainConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "InvalidTypeException":
        case "com.amazonaws.elasticsearchservice#InvalidTypeException":
            throw await deserializeAws_restJson1InvalidTypeExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.elasticsearchservice#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1UpdatePackageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdatePackageCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.PackageDetails != null) {
        contents.PackageDetails = deserializeAws_restJson1PackageDetails(data.PackageDetails, context);
    }
    return contents;
};
const deserializeAws_restJson1UpdatePackageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.elasticsearchservice#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.elasticsearchservice#LimitExceededException":
            throw await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1UpdateVpcEndpointCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateVpcEndpointCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.VpcEndpoint != null) {
        contents.VpcEndpoint = deserializeAws_restJson1VpcEndpoint(data.VpcEndpoint, context);
    }
    return contents;
};
const deserializeAws_restJson1UpdateVpcEndpointCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.elasticsearchservice#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "DisabledOperationException":
        case "com.amazonaws.elasticsearchservice#DisabledOperationException":
            throw await deserializeAws_restJson1DisabledOperationExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_restJson1UpgradeElasticsearchDomainCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpgradeElasticsearchDomainCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    if (data.ChangeProgressDetails != null) {
        contents.ChangeProgressDetails = deserializeAws_restJson1ChangeProgressDetails(data.ChangeProgressDetails, context);
    }
    if (data.DomainName != null) {
        contents.DomainName = __expectString(data.DomainName);
    }
    if (data.PerformCheckOnly != null) {
        contents.PerformCheckOnly = __expectBoolean(data.PerformCheckOnly);
    }
    if (data.TargetVersion != null) {
        contents.TargetVersion = __expectString(data.TargetVersion);
    }
    return contents;
};
const deserializeAws_restJson1UpgradeElasticsearchDomainCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.elasticsearchservice#BaseException":
            throw await deserializeAws_restJson1BaseExceptionResponse(parsedOutput, context);
        case "DisabledOperationException":
        case "com.amazonaws.elasticsearchservice#DisabledOperationException":
            throw await deserializeAws_restJson1DisabledOperationExceptionResponse(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.elasticsearchservice#InternalException":
            throw await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.elasticsearchservice#ResourceAlreadyExistsException":
            throw await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.elasticsearchservice#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.elasticsearchservice#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
const map = __map;
const deserializeAws_restJson1AccessDeniedExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1BaseExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new BaseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1ConflictExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1DisabledOperationExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new DisabledOperationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1InternalExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new InternalException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1InvalidPaginationTokenExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new InvalidPaginationTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1InvalidTypeExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new InvalidTypeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1LimitExceededExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new ResourceAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1ResourceNotFoundExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeAws_restJson1ValidationExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = __expectString(data.message);
    }
    const exception = new ValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const serializeAws_restJson1AdvancedOptions = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const serializeAws_restJson1AdvancedSecurityOptionsInput = (input, context) => {
    return {
        ...(input.AnonymousAuthEnabled != null && { AnonymousAuthEnabled: input.AnonymousAuthEnabled }),
        ...(input.Enabled != null && { Enabled: input.Enabled }),
        ...(input.InternalUserDatabaseEnabled != null && {
            InternalUserDatabaseEnabled: input.InternalUserDatabaseEnabled,
        }),
        ...(input.MasterUserOptions != null && {
            MasterUserOptions: serializeAws_restJson1MasterUserOptions(input.MasterUserOptions, context),
        }),
        ...(input.SAMLOptions != null && {
            SAMLOptions: serializeAws_restJson1SAMLOptionsInput(input.SAMLOptions, context),
        }),
    };
};
const serializeAws_restJson1AutoTuneMaintenanceSchedule = (input, context) => {
    return {
        ...(input.CronExpressionForRecurrence != null && {
            CronExpressionForRecurrence: input.CronExpressionForRecurrence,
        }),
        ...(input.Duration != null && { Duration: serializeAws_restJson1Duration(input.Duration, context) }),
        ...(input.StartAt != null && { StartAt: Math.round(input.StartAt.getTime() / 1000) }),
    };
};
const serializeAws_restJson1AutoTuneMaintenanceScheduleList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_restJson1AutoTuneMaintenanceSchedule(entry, context);
    });
};
const serializeAws_restJson1AutoTuneOptions = (input, context) => {
    return {
        ...(input.DesiredState != null && { DesiredState: input.DesiredState }),
        ...(input.MaintenanceSchedules != null && {
            MaintenanceSchedules: serializeAws_restJson1AutoTuneMaintenanceScheduleList(input.MaintenanceSchedules, context),
        }),
        ...(input.RollbackOnDisable != null && { RollbackOnDisable: input.RollbackOnDisable }),
    };
};
const serializeAws_restJson1AutoTuneOptionsInput = (input, context) => {
    return {
        ...(input.DesiredState != null && { DesiredState: input.DesiredState }),
        ...(input.MaintenanceSchedules != null && {
            MaintenanceSchedules: serializeAws_restJson1AutoTuneMaintenanceScheduleList(input.MaintenanceSchedules, context),
        }),
    };
};
const serializeAws_restJson1CognitoOptions = (input, context) => {
    return {
        ...(input.Enabled != null && { Enabled: input.Enabled }),
        ...(input.IdentityPoolId != null && { IdentityPoolId: input.IdentityPoolId }),
        ...(input.RoleArn != null && { RoleArn: input.RoleArn }),
        ...(input.UserPoolId != null && { UserPoolId: input.UserPoolId }),
    };
};
const serializeAws_restJson1ColdStorageOptions = (input, context) => {
    return {
        ...(input.Enabled != null && { Enabled: input.Enabled }),
    };
};
const serializeAws_restJson1DescribePackagesFilter = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Value != null && { Value: serializeAws_restJson1DescribePackagesFilterValues(input.Value, context) }),
    };
};
const serializeAws_restJson1DescribePackagesFilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_restJson1DescribePackagesFilter(entry, context);
    });
};
const serializeAws_restJson1DescribePackagesFilterValues = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1DomainEndpointOptions = (input, context) => {
    return {
        ...(input.CustomEndpoint != null && { CustomEndpoint: input.CustomEndpoint }),
        ...(input.CustomEndpointCertificateArn != null && {
            CustomEndpointCertificateArn: input.CustomEndpointCertificateArn,
        }),
        ...(input.CustomEndpointEnabled != null && { CustomEndpointEnabled: input.CustomEndpointEnabled }),
        ...(input.EnforceHTTPS != null && { EnforceHTTPS: input.EnforceHTTPS }),
        ...(input.TLSSecurityPolicy != null && { TLSSecurityPolicy: input.TLSSecurityPolicy }),
    };
};
const serializeAws_restJson1DomainInformation = (input, context) => {
    return {
        ...(input.DomainName != null && { DomainName: input.DomainName }),
        ...(input.OwnerId != null && { OwnerId: input.OwnerId }),
        ...(input.Region != null && { Region: input.Region }),
    };
};
const serializeAws_restJson1DomainNameList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1Duration = (input, context) => {
    return {
        ...(input.Unit != null && { Unit: input.Unit }),
        ...(input.Value != null && { Value: input.Value }),
    };
};
const serializeAws_restJson1EBSOptions = (input, context) => {
    return {
        ...(input.EBSEnabled != null && { EBSEnabled: input.EBSEnabled }),
        ...(input.Iops != null && { Iops: input.Iops }),
        ...(input.Throughput != null && { Throughput: input.Throughput }),
        ...(input.VolumeSize != null && { VolumeSize: input.VolumeSize }),
        ...(input.VolumeType != null && { VolumeType: input.VolumeType }),
    };
};
const serializeAws_restJson1ElasticsearchClusterConfig = (input, context) => {
    return {
        ...(input.ColdStorageOptions != null && {
            ColdStorageOptions: serializeAws_restJson1ColdStorageOptions(input.ColdStorageOptions, context),
        }),
        ...(input.DedicatedMasterCount != null && { DedicatedMasterCount: input.DedicatedMasterCount }),
        ...(input.DedicatedMasterEnabled != null && { DedicatedMasterEnabled: input.DedicatedMasterEnabled }),
        ...(input.DedicatedMasterType != null && { DedicatedMasterType: input.DedicatedMasterType }),
        ...(input.InstanceCount != null && { InstanceCount: input.InstanceCount }),
        ...(input.InstanceType != null && { InstanceType: input.InstanceType }),
        ...(input.WarmCount != null && { WarmCount: input.WarmCount }),
        ...(input.WarmEnabled != null && { WarmEnabled: input.WarmEnabled }),
        ...(input.WarmType != null && { WarmType: input.WarmType }),
        ...(input.ZoneAwarenessConfig != null && {
            ZoneAwarenessConfig: serializeAws_restJson1ZoneAwarenessConfig(input.ZoneAwarenessConfig, context),
        }),
        ...(input.ZoneAwarenessEnabled != null && { ZoneAwarenessEnabled: input.ZoneAwarenessEnabled }),
    };
};
const serializeAws_restJson1EncryptionAtRestOptions = (input, context) => {
    return {
        ...(input.Enabled != null && { Enabled: input.Enabled }),
        ...(input.KmsKeyId != null && { KmsKeyId: input.KmsKeyId }),
    };
};
const serializeAws_restJson1Filter = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Values != null && { Values: serializeAws_restJson1ValueStringList(input.Values, context) }),
    };
};
const serializeAws_restJson1FilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_restJson1Filter(entry, context);
    });
};
const serializeAws_restJson1LogPublishingOption = (input, context) => {
    return {
        ...(input.CloudWatchLogsLogGroupArn != null && { CloudWatchLogsLogGroupArn: input.CloudWatchLogsLogGroupArn }),
        ...(input.Enabled != null && { Enabled: input.Enabled }),
    };
};
const serializeAws_restJson1LogPublishingOptions = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = serializeAws_restJson1LogPublishingOption(value, context);
        return acc;
    }, {});
};
const serializeAws_restJson1MasterUserOptions = (input, context) => {
    return {
        ...(input.MasterUserARN != null && { MasterUserARN: input.MasterUserARN }),
        ...(input.MasterUserName != null && { MasterUserName: input.MasterUserName }),
        ...(input.MasterUserPassword != null && { MasterUserPassword: input.MasterUserPassword }),
    };
};
const serializeAws_restJson1NodeToNodeEncryptionOptions = (input, context) => {
    return {
        ...(input.Enabled != null && { Enabled: input.Enabled }),
    };
};
const serializeAws_restJson1PackageSource = (input, context) => {
    return {
        ...(input.S3BucketName != null && { S3BucketName: input.S3BucketName }),
        ...(input.S3Key != null && { S3Key: input.S3Key }),
    };
};
const serializeAws_restJson1SAMLIdp = (input, context) => {
    return {
        ...(input.EntityId != null && { EntityId: input.EntityId }),
        ...(input.MetadataContent != null && { MetadataContent: input.MetadataContent }),
    };
};
const serializeAws_restJson1SAMLOptionsInput = (input, context) => {
    return {
        ...(input.Enabled != null && { Enabled: input.Enabled }),
        ...(input.Idp != null && { Idp: serializeAws_restJson1SAMLIdp(input.Idp, context) }),
        ...(input.MasterBackendRole != null && { MasterBackendRole: input.MasterBackendRole }),
        ...(input.MasterUserName != null && { MasterUserName: input.MasterUserName }),
        ...(input.RolesKey != null && { RolesKey: input.RolesKey }),
        ...(input.SessionTimeoutMinutes != null && { SessionTimeoutMinutes: input.SessionTimeoutMinutes }),
        ...(input.SubjectKey != null && { SubjectKey: input.SubjectKey }),
    };
};
const serializeAws_restJson1SnapshotOptions = (input, context) => {
    return {
        ...(input.AutomatedSnapshotStartHour != null && { AutomatedSnapshotStartHour: input.AutomatedSnapshotStartHour }),
    };
};
const serializeAws_restJson1StringList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1Tag = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Value != null && { Value: input.Value }),
    };
};
const serializeAws_restJson1TagList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_restJson1Tag(entry, context);
    });
};
const serializeAws_restJson1ValueStringList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1VpcEndpointIdList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_restJson1VPCOptions = (input, context) => {
    return {
        ...(input.SecurityGroupIds != null && {
            SecurityGroupIds: serializeAws_restJson1StringList(input.SecurityGroupIds, context),
        }),
        ...(input.SubnetIds != null && { SubnetIds: serializeAws_restJson1StringList(input.SubnetIds, context) }),
    };
};
const serializeAws_restJson1ZoneAwarenessConfig = (input, context) => {
    return {
        ...(input.AvailabilityZoneCount != null && { AvailabilityZoneCount: input.AvailabilityZoneCount }),
    };
};
const deserializeAws_restJson1AccessPoliciesStatus = (output, context) => {
    return {
        Options: __expectString(output.Options),
        Status: output.Status != null ? deserializeAws_restJson1OptionStatus(output.Status, context) : undefined,
    };
};
const deserializeAws_restJson1AdditionalLimit = (output, context) => {
    return {
        LimitName: __expectString(output.LimitName),
        LimitValues: output.LimitValues != null ? deserializeAws_restJson1LimitValueList(output.LimitValues, context) : undefined,
    };
};
const deserializeAws_restJson1AdditionalLimitList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1AdditionalLimit(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1AdvancedOptions = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectString(value);
        return acc;
    }, {});
};
const deserializeAws_restJson1AdvancedOptionsStatus = (output, context) => {
    return {
        Options: output.Options != null ? deserializeAws_restJson1AdvancedOptions(output.Options, context) : undefined,
        Status: output.Status != null ? deserializeAws_restJson1OptionStatus(output.Status, context) : undefined,
    };
};
const deserializeAws_restJson1AdvancedSecurityOptions = (output, context) => {
    return {
        AnonymousAuthDisableDate: output.AnonymousAuthDisableDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.AnonymousAuthDisableDate)))
            : undefined,
        AnonymousAuthEnabled: __expectBoolean(output.AnonymousAuthEnabled),
        Enabled: __expectBoolean(output.Enabled),
        InternalUserDatabaseEnabled: __expectBoolean(output.InternalUserDatabaseEnabled),
        SAMLOptions: output.SAMLOptions != null ? deserializeAws_restJson1SAMLOptionsOutput(output.SAMLOptions, context) : undefined,
    };
};
const deserializeAws_restJson1AdvancedSecurityOptionsStatus = (output, context) => {
    return {
        Options: output.Options != null ? deserializeAws_restJson1AdvancedSecurityOptions(output.Options, context) : undefined,
        Status: output.Status != null ? deserializeAws_restJson1OptionStatus(output.Status, context) : undefined,
    };
};
const deserializeAws_restJson1AuthorizedPrincipal = (output, context) => {
    return {
        Principal: __expectString(output.Principal),
        PrincipalType: __expectString(output.PrincipalType),
    };
};
const deserializeAws_restJson1AuthorizedPrincipalList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1AuthorizedPrincipal(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1AutoTune = (output, context) => {
    return {
        AutoTuneDetails: output.AutoTuneDetails != null
            ? deserializeAws_restJson1AutoTuneDetails(output.AutoTuneDetails, context)
            : undefined,
        AutoTuneType: __expectString(output.AutoTuneType),
    };
};
const deserializeAws_restJson1AutoTuneDetails = (output, context) => {
    return {
        ScheduledAutoTuneDetails: output.ScheduledAutoTuneDetails != null
            ? deserializeAws_restJson1ScheduledAutoTuneDetails(output.ScheduledAutoTuneDetails, context)
            : undefined,
    };
};
const deserializeAws_restJson1AutoTuneList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1AutoTune(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1AutoTuneMaintenanceSchedule = (output, context) => {
    return {
        CronExpressionForRecurrence: __expectString(output.CronExpressionForRecurrence),
        Duration: output.Duration != null ? deserializeAws_restJson1Duration(output.Duration, context) : undefined,
        StartAt: output.StartAt != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartAt))) : undefined,
    };
};
const deserializeAws_restJson1AutoTuneMaintenanceScheduleList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1AutoTuneMaintenanceSchedule(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1AutoTuneOptions = (output, context) => {
    return {
        DesiredState: __expectString(output.DesiredState),
        MaintenanceSchedules: output.MaintenanceSchedules != null
            ? deserializeAws_restJson1AutoTuneMaintenanceScheduleList(output.MaintenanceSchedules, context)
            : undefined,
        RollbackOnDisable: __expectString(output.RollbackOnDisable),
    };
};
const deserializeAws_restJson1AutoTuneOptionsOutput = (output, context) => {
    return {
        ErrorMessage: __expectString(output.ErrorMessage),
        State: __expectString(output.State),
    };
};
const deserializeAws_restJson1AutoTuneOptionsStatus = (output, context) => {
    return {
        Options: output.Options != null ? deserializeAws_restJson1AutoTuneOptions(output.Options, context) : undefined,
        Status: output.Status != null ? deserializeAws_restJson1AutoTuneStatus(output.Status, context) : undefined,
    };
};
const deserializeAws_restJson1AutoTuneStatus = (output, context) => {
    return {
        CreationDate: output.CreationDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreationDate)))
            : undefined,
        ErrorMessage: __expectString(output.ErrorMessage),
        PendingDeletion: __expectBoolean(output.PendingDeletion),
        State: __expectString(output.State),
        UpdateDate: output.UpdateDate != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.UpdateDate))) : undefined,
        UpdateVersion: __expectInt32(output.UpdateVersion),
    };
};
const deserializeAws_restJson1ChangeProgressDetails = (output, context) => {
    return {
        ChangeId: __expectString(output.ChangeId),
        Message: __expectString(output.Message),
    };
};
const deserializeAws_restJson1ChangeProgressStage = (output, context) => {
    return {
        Description: __expectString(output.Description),
        LastUpdated: output.LastUpdated != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastUpdated)))
            : undefined,
        Name: __expectString(output.Name),
        Status: __expectString(output.Status),
    };
};
const deserializeAws_restJson1ChangeProgressStageList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ChangeProgressStage(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ChangeProgressStatusDetails = (output, context) => {
    return {
        ChangeId: __expectString(output.ChangeId),
        ChangeProgressStages: output.ChangeProgressStages != null
            ? deserializeAws_restJson1ChangeProgressStageList(output.ChangeProgressStages, context)
            : undefined,
        CompletedProperties: output.CompletedProperties != null
            ? deserializeAws_restJson1StringList(output.CompletedProperties, context)
            : undefined,
        PendingProperties: output.PendingProperties != null
            ? deserializeAws_restJson1StringList(output.PendingProperties, context)
            : undefined,
        StartTime: output.StartTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartTime))) : undefined,
        Status: __expectString(output.Status),
        TotalNumberOfStages: __expectInt32(output.TotalNumberOfStages),
    };
};
const deserializeAws_restJson1CognitoOptions = (output, context) => {
    return {
        Enabled: __expectBoolean(output.Enabled),
        IdentityPoolId: __expectString(output.IdentityPoolId),
        RoleArn: __expectString(output.RoleArn),
        UserPoolId: __expectString(output.UserPoolId),
    };
};
const deserializeAws_restJson1CognitoOptionsStatus = (output, context) => {
    return {
        Options: output.Options != null ? deserializeAws_restJson1CognitoOptions(output.Options, context) : undefined,
        Status: output.Status != null ? deserializeAws_restJson1OptionStatus(output.Status, context) : undefined,
    };
};
const deserializeAws_restJson1ColdStorageOptions = (output, context) => {
    return {
        Enabled: __expectBoolean(output.Enabled),
    };
};
const deserializeAws_restJson1CompatibleElasticsearchVersionsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1CompatibleVersionsMap(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1CompatibleVersionsMap = (output, context) => {
    return {
        SourceVersion: __expectString(output.SourceVersion),
        TargetVersions: output.TargetVersions != null
            ? deserializeAws_restJson1ElasticsearchVersionList(output.TargetVersions, context)
            : undefined,
    };
};
const deserializeAws_restJson1DomainEndpointOptions = (output, context) => {
    return {
        CustomEndpoint: __expectString(output.CustomEndpoint),
        CustomEndpointCertificateArn: __expectString(output.CustomEndpointCertificateArn),
        CustomEndpointEnabled: __expectBoolean(output.CustomEndpointEnabled),
        EnforceHTTPS: __expectBoolean(output.EnforceHTTPS),
        TLSSecurityPolicy: __expectString(output.TLSSecurityPolicy),
    };
};
const deserializeAws_restJson1DomainEndpointOptionsStatus = (output, context) => {
    return {
        Options: output.Options != null ? deserializeAws_restJson1DomainEndpointOptions(output.Options, context) : undefined,
        Status: output.Status != null ? deserializeAws_restJson1OptionStatus(output.Status, context) : undefined,
    };
};
const deserializeAws_restJson1DomainInfo = (output, context) => {
    return {
        DomainName: __expectString(output.DomainName),
        EngineType: __expectString(output.EngineType),
    };
};
const deserializeAws_restJson1DomainInfoList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1DomainInfo(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1DomainInformation = (output, context) => {
    return {
        DomainName: __expectString(output.DomainName),
        OwnerId: __expectString(output.OwnerId),
        Region: __expectString(output.Region),
    };
};
const deserializeAws_restJson1DomainPackageDetails = (output, context) => {
    return {
        DomainName: __expectString(output.DomainName),
        DomainPackageStatus: __expectString(output.DomainPackageStatus),
        ErrorDetails: output.ErrorDetails != null ? deserializeAws_restJson1ErrorDetails(output.ErrorDetails, context) : undefined,
        LastUpdated: output.LastUpdated != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastUpdated)))
            : undefined,
        PackageID: __expectString(output.PackageID),
        PackageName: __expectString(output.PackageName),
        PackageType: __expectString(output.PackageType),
        PackageVersion: __expectString(output.PackageVersion),
        ReferencePath: __expectString(output.ReferencePath),
    };
};
const deserializeAws_restJson1DomainPackageDetailsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1DomainPackageDetails(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1DryRunResults = (output, context) => {
    return {
        DeploymentType: __expectString(output.DeploymentType),
        Message: __expectString(output.Message),
    };
};
const deserializeAws_restJson1Duration = (output, context) => {
    return {
        Unit: __expectString(output.Unit),
        Value: __expectLong(output.Value),
    };
};
const deserializeAws_restJson1EBSOptions = (output, context) => {
    return {
        EBSEnabled: __expectBoolean(output.EBSEnabled),
        Iops: __expectInt32(output.Iops),
        Throughput: __expectInt32(output.Throughput),
        VolumeSize: __expectInt32(output.VolumeSize),
        VolumeType: __expectString(output.VolumeType),
    };
};
const deserializeAws_restJson1EBSOptionsStatus = (output, context) => {
    return {
        Options: output.Options != null ? deserializeAws_restJson1EBSOptions(output.Options, context) : undefined,
        Status: output.Status != null ? deserializeAws_restJson1OptionStatus(output.Status, context) : undefined,
    };
};
const deserializeAws_restJson1ElasticsearchClusterConfig = (output, context) => {
    return {
        ColdStorageOptions: output.ColdStorageOptions != null
            ? deserializeAws_restJson1ColdStorageOptions(output.ColdStorageOptions, context)
            : undefined,
        DedicatedMasterCount: __expectInt32(output.DedicatedMasterCount),
        DedicatedMasterEnabled: __expectBoolean(output.DedicatedMasterEnabled),
        DedicatedMasterType: __expectString(output.DedicatedMasterType),
        InstanceCount: __expectInt32(output.InstanceCount),
        InstanceType: __expectString(output.InstanceType),
        WarmCount: __expectInt32(output.WarmCount),
        WarmEnabled: __expectBoolean(output.WarmEnabled),
        WarmType: __expectString(output.WarmType),
        ZoneAwarenessConfig: output.ZoneAwarenessConfig != null
            ? deserializeAws_restJson1ZoneAwarenessConfig(output.ZoneAwarenessConfig, context)
            : undefined,
        ZoneAwarenessEnabled: __expectBoolean(output.ZoneAwarenessEnabled),
    };
};
const deserializeAws_restJson1ElasticsearchClusterConfigStatus = (output, context) => {
    return {
        Options: output.Options != null ? deserializeAws_restJson1ElasticsearchClusterConfig(output.Options, context) : undefined,
        Status: output.Status != null ? deserializeAws_restJson1OptionStatus(output.Status, context) : undefined,
    };
};
const deserializeAws_restJson1ElasticsearchDomainConfig = (output, context) => {
    return {
        AccessPolicies: output.AccessPolicies != null
            ? deserializeAws_restJson1AccessPoliciesStatus(output.AccessPolicies, context)
            : undefined,
        AdvancedOptions: output.AdvancedOptions != null
            ? deserializeAws_restJson1AdvancedOptionsStatus(output.AdvancedOptions, context)
            : undefined,
        AdvancedSecurityOptions: output.AdvancedSecurityOptions != null
            ? deserializeAws_restJson1AdvancedSecurityOptionsStatus(output.AdvancedSecurityOptions, context)
            : undefined,
        AutoTuneOptions: output.AutoTuneOptions != null
            ? deserializeAws_restJson1AutoTuneOptionsStatus(output.AutoTuneOptions, context)
            : undefined,
        ChangeProgressDetails: output.ChangeProgressDetails != null
            ? deserializeAws_restJson1ChangeProgressDetails(output.ChangeProgressDetails, context)
            : undefined,
        CognitoOptions: output.CognitoOptions != null
            ? deserializeAws_restJson1CognitoOptionsStatus(output.CognitoOptions, context)
            : undefined,
        DomainEndpointOptions: output.DomainEndpointOptions != null
            ? deserializeAws_restJson1DomainEndpointOptionsStatus(output.DomainEndpointOptions, context)
            : undefined,
        EBSOptions: output.EBSOptions != null ? deserializeAws_restJson1EBSOptionsStatus(output.EBSOptions, context) : undefined,
        ElasticsearchClusterConfig: output.ElasticsearchClusterConfig != null
            ? deserializeAws_restJson1ElasticsearchClusterConfigStatus(output.ElasticsearchClusterConfig, context)
            : undefined,
        ElasticsearchVersion: output.ElasticsearchVersion != null
            ? deserializeAws_restJson1ElasticsearchVersionStatus(output.ElasticsearchVersion, context)
            : undefined,
        EncryptionAtRestOptions: output.EncryptionAtRestOptions != null
            ? deserializeAws_restJson1EncryptionAtRestOptionsStatus(output.EncryptionAtRestOptions, context)
            : undefined,
        LogPublishingOptions: output.LogPublishingOptions != null
            ? deserializeAws_restJson1LogPublishingOptionsStatus(output.LogPublishingOptions, context)
            : undefined,
        NodeToNodeEncryptionOptions: output.NodeToNodeEncryptionOptions != null
            ? deserializeAws_restJson1NodeToNodeEncryptionOptionsStatus(output.NodeToNodeEncryptionOptions, context)
            : undefined,
        SnapshotOptions: output.SnapshotOptions != null
            ? deserializeAws_restJson1SnapshotOptionsStatus(output.SnapshotOptions, context)
            : undefined,
        VPCOptions: output.VPCOptions != null ? deserializeAws_restJson1VPCDerivedInfoStatus(output.VPCOptions, context) : undefined,
    };
};
const deserializeAws_restJson1ElasticsearchDomainStatus = (output, context) => {
    return {
        ARN: __expectString(output.ARN),
        AccessPolicies: __expectString(output.AccessPolicies),
        AdvancedOptions: output.AdvancedOptions != null
            ? deserializeAws_restJson1AdvancedOptions(output.AdvancedOptions, context)
            : undefined,
        AdvancedSecurityOptions: output.AdvancedSecurityOptions != null
            ? deserializeAws_restJson1AdvancedSecurityOptions(output.AdvancedSecurityOptions, context)
            : undefined,
        AutoTuneOptions: output.AutoTuneOptions != null
            ? deserializeAws_restJson1AutoTuneOptionsOutput(output.AutoTuneOptions, context)
            : undefined,
        ChangeProgressDetails: output.ChangeProgressDetails != null
            ? deserializeAws_restJson1ChangeProgressDetails(output.ChangeProgressDetails, context)
            : undefined,
        CognitoOptions: output.CognitoOptions != null
            ? deserializeAws_restJson1CognitoOptions(output.CognitoOptions, context)
            : undefined,
        Created: __expectBoolean(output.Created),
        Deleted: __expectBoolean(output.Deleted),
        DomainEndpointOptions: output.DomainEndpointOptions != null
            ? deserializeAws_restJson1DomainEndpointOptions(output.DomainEndpointOptions, context)
            : undefined,
        DomainId: __expectString(output.DomainId),
        DomainName: __expectString(output.DomainName),
        EBSOptions: output.EBSOptions != null ? deserializeAws_restJson1EBSOptions(output.EBSOptions, context) : undefined,
        ElasticsearchClusterConfig: output.ElasticsearchClusterConfig != null
            ? deserializeAws_restJson1ElasticsearchClusterConfig(output.ElasticsearchClusterConfig, context)
            : undefined,
        ElasticsearchVersion: __expectString(output.ElasticsearchVersion),
        EncryptionAtRestOptions: output.EncryptionAtRestOptions != null
            ? deserializeAws_restJson1EncryptionAtRestOptions(output.EncryptionAtRestOptions, context)
            : undefined,
        Endpoint: __expectString(output.Endpoint),
        Endpoints: output.Endpoints != null ? deserializeAws_restJson1EndpointsMap(output.Endpoints, context) : undefined,
        LogPublishingOptions: output.LogPublishingOptions != null
            ? deserializeAws_restJson1LogPublishingOptions(output.LogPublishingOptions, context)
            : undefined,
        NodeToNodeEncryptionOptions: output.NodeToNodeEncryptionOptions != null
            ? deserializeAws_restJson1NodeToNodeEncryptionOptions(output.NodeToNodeEncryptionOptions, context)
            : undefined,
        Processing: __expectBoolean(output.Processing),
        ServiceSoftwareOptions: output.ServiceSoftwareOptions != null
            ? deserializeAws_restJson1ServiceSoftwareOptions(output.ServiceSoftwareOptions, context)
            : undefined,
        SnapshotOptions: output.SnapshotOptions != null
            ? deserializeAws_restJson1SnapshotOptions(output.SnapshotOptions, context)
            : undefined,
        UpgradeProcessing: __expectBoolean(output.UpgradeProcessing),
        VPCOptions: output.VPCOptions != null ? deserializeAws_restJson1VPCDerivedInfo(output.VPCOptions, context) : undefined,
    };
};
const deserializeAws_restJson1ElasticsearchDomainStatusList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ElasticsearchDomainStatus(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ElasticsearchInstanceTypeList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1ElasticsearchVersionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1ElasticsearchVersionStatus = (output, context) => {
    return {
        Options: __expectString(output.Options),
        Status: output.Status != null ? deserializeAws_restJson1OptionStatus(output.Status, context) : undefined,
    };
};
const deserializeAws_restJson1EncryptionAtRestOptions = (output, context) => {
    return {
        Enabled: __expectBoolean(output.Enabled),
        KmsKeyId: __expectString(output.KmsKeyId),
    };
};
const deserializeAws_restJson1EncryptionAtRestOptionsStatus = (output, context) => {
    return {
        Options: output.Options != null ? deserializeAws_restJson1EncryptionAtRestOptions(output.Options, context) : undefined,
        Status: output.Status != null ? deserializeAws_restJson1OptionStatus(output.Status, context) : undefined,
    };
};
const deserializeAws_restJson1EndpointsMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectString(value);
        return acc;
    }, {});
};
const deserializeAws_restJson1ErrorDetails = (output, context) => {
    return {
        ErrorMessage: __expectString(output.ErrorMessage),
        ErrorType: __expectString(output.ErrorType),
    };
};
const deserializeAws_restJson1InboundCrossClusterSearchConnection = (output, context) => {
    return {
        ConnectionStatus: output.ConnectionStatus != null
            ? deserializeAws_restJson1InboundCrossClusterSearchConnectionStatus(output.ConnectionStatus, context)
            : undefined,
        CrossClusterSearchConnectionId: __expectString(output.CrossClusterSearchConnectionId),
        DestinationDomainInfo: output.DestinationDomainInfo != null
            ? deserializeAws_restJson1DomainInformation(output.DestinationDomainInfo, context)
            : undefined,
        SourceDomainInfo: output.SourceDomainInfo != null
            ? deserializeAws_restJson1DomainInformation(output.SourceDomainInfo, context)
            : undefined,
    };
};
const deserializeAws_restJson1InboundCrossClusterSearchConnections = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1InboundCrossClusterSearchConnection(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1InboundCrossClusterSearchConnectionStatus = (output, context) => {
    return {
        Message: __expectString(output.Message),
        StatusCode: __expectString(output.StatusCode),
    };
};
const deserializeAws_restJson1InstanceCountLimits = (output, context) => {
    return {
        MaximumInstanceCount: __expectInt32(output.MaximumInstanceCount),
        MinimumInstanceCount: __expectInt32(output.MinimumInstanceCount),
    };
};
const deserializeAws_restJson1InstanceLimits = (output, context) => {
    return {
        InstanceCountLimits: output.InstanceCountLimits != null
            ? deserializeAws_restJson1InstanceCountLimits(output.InstanceCountLimits, context)
            : undefined,
    };
};
const deserializeAws_restJson1Issues = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1Limits = (output, context) => {
    return {
        AdditionalLimits: output.AdditionalLimits != null
            ? deserializeAws_restJson1AdditionalLimitList(output.AdditionalLimits, context)
            : undefined,
        InstanceLimits: output.InstanceLimits != null
            ? deserializeAws_restJson1InstanceLimits(output.InstanceLimits, context)
            : undefined,
        StorageTypes: output.StorageTypes != null ? deserializeAws_restJson1StorageTypeList(output.StorageTypes, context) : undefined,
    };
};
const deserializeAws_restJson1LimitsByRole = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = deserializeAws_restJson1Limits(value, context);
        return acc;
    }, {});
};
const deserializeAws_restJson1LimitValueList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1LogPublishingOption = (output, context) => {
    return {
        CloudWatchLogsLogGroupArn: __expectString(output.CloudWatchLogsLogGroupArn),
        Enabled: __expectBoolean(output.Enabled),
    };
};
const deserializeAws_restJson1LogPublishingOptions = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = deserializeAws_restJson1LogPublishingOption(value, context);
        return acc;
    }, {});
};
const deserializeAws_restJson1LogPublishingOptionsStatus = (output, context) => {
    return {
        Options: output.Options != null ? deserializeAws_restJson1LogPublishingOptions(output.Options, context) : undefined,
        Status: output.Status != null ? deserializeAws_restJson1OptionStatus(output.Status, context) : undefined,
    };
};
const deserializeAws_restJson1NodeToNodeEncryptionOptions = (output, context) => {
    return {
        Enabled: __expectBoolean(output.Enabled),
    };
};
const deserializeAws_restJson1NodeToNodeEncryptionOptionsStatus = (output, context) => {
    return {
        Options: output.Options != null ? deserializeAws_restJson1NodeToNodeEncryptionOptions(output.Options, context) : undefined,
        Status: output.Status != null ? deserializeAws_restJson1OptionStatus(output.Status, context) : undefined,
    };
};
const deserializeAws_restJson1OptionStatus = (output, context) => {
    return {
        CreationDate: output.CreationDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreationDate)))
            : undefined,
        PendingDeletion: __expectBoolean(output.PendingDeletion),
        State: __expectString(output.State),
        UpdateDate: output.UpdateDate != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.UpdateDate))) : undefined,
        UpdateVersion: __expectInt32(output.UpdateVersion),
    };
};
const deserializeAws_restJson1OutboundCrossClusterSearchConnection = (output, context) => {
    return {
        ConnectionAlias: __expectString(output.ConnectionAlias),
        ConnectionStatus: output.ConnectionStatus != null
            ? deserializeAws_restJson1OutboundCrossClusterSearchConnectionStatus(output.ConnectionStatus, context)
            : undefined,
        CrossClusterSearchConnectionId: __expectString(output.CrossClusterSearchConnectionId),
        DestinationDomainInfo: output.DestinationDomainInfo != null
            ? deserializeAws_restJson1DomainInformation(output.DestinationDomainInfo, context)
            : undefined,
        SourceDomainInfo: output.SourceDomainInfo != null
            ? deserializeAws_restJson1DomainInformation(output.SourceDomainInfo, context)
            : undefined,
    };
};
const deserializeAws_restJson1OutboundCrossClusterSearchConnections = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1OutboundCrossClusterSearchConnection(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1OutboundCrossClusterSearchConnectionStatus = (output, context) => {
    return {
        Message: __expectString(output.Message),
        StatusCode: __expectString(output.StatusCode),
    };
};
const deserializeAws_restJson1PackageDetails = (output, context) => {
    return {
        AvailablePackageVersion: __expectString(output.AvailablePackageVersion),
        CreatedAt: output.CreatedAt != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedAt))) : undefined,
        ErrorDetails: output.ErrorDetails != null ? deserializeAws_restJson1ErrorDetails(output.ErrorDetails, context) : undefined,
        LastUpdatedAt: output.LastUpdatedAt != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastUpdatedAt)))
            : undefined,
        PackageDescription: __expectString(output.PackageDescription),
        PackageID: __expectString(output.PackageID),
        PackageName: __expectString(output.PackageName),
        PackageStatus: __expectString(output.PackageStatus),
        PackageType: __expectString(output.PackageType),
    };
};
const deserializeAws_restJson1PackageDetailsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1PackageDetails(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1PackageVersionHistory = (output, context) => {
    return {
        CommitMessage: __expectString(output.CommitMessage),
        CreatedAt: output.CreatedAt != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedAt))) : undefined,
        PackageVersion: __expectString(output.PackageVersion),
    };
};
const deserializeAws_restJson1PackageVersionHistoryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1PackageVersionHistory(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1RecurringCharge = (output, context) => {
    return {
        RecurringChargeAmount: __limitedParseDouble(output.RecurringChargeAmount),
        RecurringChargeFrequency: __expectString(output.RecurringChargeFrequency),
    };
};
const deserializeAws_restJson1RecurringChargeList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1RecurringCharge(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ReservedElasticsearchInstance = (output, context) => {
    return {
        CurrencyCode: __expectString(output.CurrencyCode),
        Duration: __expectInt32(output.Duration),
        ElasticsearchInstanceCount: __expectInt32(output.ElasticsearchInstanceCount),
        ElasticsearchInstanceType: __expectString(output.ElasticsearchInstanceType),
        FixedPrice: __limitedParseDouble(output.FixedPrice),
        PaymentOption: __expectString(output.PaymentOption),
        RecurringCharges: output.RecurringCharges != null
            ? deserializeAws_restJson1RecurringChargeList(output.RecurringCharges, context)
            : undefined,
        ReservationName: __expectString(output.ReservationName),
        ReservedElasticsearchInstanceId: __expectString(output.ReservedElasticsearchInstanceId),
        ReservedElasticsearchInstanceOfferingId: __expectString(output.ReservedElasticsearchInstanceOfferingId),
        StartTime: output.StartTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartTime))) : undefined,
        State: __expectString(output.State),
        UsagePrice: __limitedParseDouble(output.UsagePrice),
    };
};
const deserializeAws_restJson1ReservedElasticsearchInstanceList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ReservedElasticsearchInstance(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ReservedElasticsearchInstanceOffering = (output, context) => {
    return {
        CurrencyCode: __expectString(output.CurrencyCode),
        Duration: __expectInt32(output.Duration),
        ElasticsearchInstanceType: __expectString(output.ElasticsearchInstanceType),
        FixedPrice: __limitedParseDouble(output.FixedPrice),
        PaymentOption: __expectString(output.PaymentOption),
        RecurringCharges: output.RecurringCharges != null
            ? deserializeAws_restJson1RecurringChargeList(output.RecurringCharges, context)
            : undefined,
        ReservedElasticsearchInstanceOfferingId: __expectString(output.ReservedElasticsearchInstanceOfferingId),
        UsagePrice: __limitedParseDouble(output.UsagePrice),
    };
};
const deserializeAws_restJson1ReservedElasticsearchInstanceOfferingList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1ReservedElasticsearchInstanceOffering(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1SAMLIdp = (output, context) => {
    return {
        EntityId: __expectString(output.EntityId),
        MetadataContent: __expectString(output.MetadataContent),
    };
};
const deserializeAws_restJson1SAMLOptionsOutput = (output, context) => {
    return {
        Enabled: __expectBoolean(output.Enabled),
        Idp: output.Idp != null ? deserializeAws_restJson1SAMLIdp(output.Idp, context) : undefined,
        RolesKey: __expectString(output.RolesKey),
        SessionTimeoutMinutes: __expectInt32(output.SessionTimeoutMinutes),
        SubjectKey: __expectString(output.SubjectKey),
    };
};
const deserializeAws_restJson1ScheduledAutoTuneDetails = (output, context) => {
    return {
        Action: __expectString(output.Action),
        ActionType: __expectString(output.ActionType),
        Date: output.Date != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.Date))) : undefined,
        Severity: __expectString(output.Severity),
    };
};
const deserializeAws_restJson1ServiceSoftwareOptions = (output, context) => {
    return {
        AutomatedUpdateDate: output.AutomatedUpdateDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.AutomatedUpdateDate)))
            : undefined,
        Cancellable: __expectBoolean(output.Cancellable),
        CurrentVersion: __expectString(output.CurrentVersion),
        Description: __expectString(output.Description),
        NewVersion: __expectString(output.NewVersion),
        OptionalDeployment: __expectBoolean(output.OptionalDeployment),
        UpdateAvailable: __expectBoolean(output.UpdateAvailable),
        UpdateStatus: __expectString(output.UpdateStatus),
    };
};
const deserializeAws_restJson1SnapshotOptions = (output, context) => {
    return {
        AutomatedSnapshotStartHour: __expectInt32(output.AutomatedSnapshotStartHour),
    };
};
const deserializeAws_restJson1SnapshotOptionsStatus = (output, context) => {
    return {
        Options: output.Options != null ? deserializeAws_restJson1SnapshotOptions(output.Options, context) : undefined,
        Status: output.Status != null ? deserializeAws_restJson1OptionStatus(output.Status, context) : undefined,
    };
};
const deserializeAws_restJson1StorageType = (output, context) => {
    return {
        StorageSubTypeName: __expectString(output.StorageSubTypeName),
        StorageTypeLimits: output.StorageTypeLimits != null
            ? deserializeAws_restJson1StorageTypeLimitList(output.StorageTypeLimits, context)
            : undefined,
        StorageTypeName: __expectString(output.StorageTypeName),
    };
};
const deserializeAws_restJson1StorageTypeLimit = (output, context) => {
    return {
        LimitName: __expectString(output.LimitName),
        LimitValues: output.LimitValues != null ? deserializeAws_restJson1LimitValueList(output.LimitValues, context) : undefined,
    };
};
const deserializeAws_restJson1StorageTypeLimitList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1StorageTypeLimit(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1StorageTypeList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1StorageType(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1StringList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_restJson1Tag = (output, context) => {
    return {
        Key: __expectString(output.Key),
        Value: __expectString(output.Value),
    };
};
const deserializeAws_restJson1TagList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1Tag(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1UpgradeHistory = (output, context) => {
    return {
        StartTimestamp: output.StartTimestamp != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartTimestamp)))
            : undefined,
        StepsList: output.StepsList != null ? deserializeAws_restJson1UpgradeStepsList(output.StepsList, context) : undefined,
        UpgradeName: __expectString(output.UpgradeName),
        UpgradeStatus: __expectString(output.UpgradeStatus),
    };
};
const deserializeAws_restJson1UpgradeHistoryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1UpgradeHistory(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1UpgradeStepItem = (output, context) => {
    return {
        Issues: output.Issues != null ? deserializeAws_restJson1Issues(output.Issues, context) : undefined,
        ProgressPercent: __limitedParseDouble(output.ProgressPercent),
        UpgradeStep: __expectString(output.UpgradeStep),
        UpgradeStepStatus: __expectString(output.UpgradeStepStatus),
    };
};
const deserializeAws_restJson1UpgradeStepsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1UpgradeStepItem(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1VPCDerivedInfo = (output, context) => {
    return {
        AvailabilityZones: output.AvailabilityZones != null
            ? deserializeAws_restJson1StringList(output.AvailabilityZones, context)
            : undefined,
        SecurityGroupIds: output.SecurityGroupIds != null
            ? deserializeAws_restJson1StringList(output.SecurityGroupIds, context)
            : undefined,
        SubnetIds: output.SubnetIds != null ? deserializeAws_restJson1StringList(output.SubnetIds, context) : undefined,
        VPCId: __expectString(output.VPCId),
    };
};
const deserializeAws_restJson1VPCDerivedInfoStatus = (output, context) => {
    return {
        Options: output.Options != null ? deserializeAws_restJson1VPCDerivedInfo(output.Options, context) : undefined,
        Status: output.Status != null ? deserializeAws_restJson1OptionStatus(output.Status, context) : undefined,
    };
};
const deserializeAws_restJson1VpcEndpoint = (output, context) => {
    return {
        DomainArn: __expectString(output.DomainArn),
        Endpoint: __expectString(output.Endpoint),
        Status: __expectString(output.Status),
        VpcEndpointId: __expectString(output.VpcEndpointId),
        VpcEndpointOwner: __expectString(output.VpcEndpointOwner),
        VpcOptions: output.VpcOptions != null ? deserializeAws_restJson1VPCDerivedInfo(output.VpcOptions, context) : undefined,
    };
};
const deserializeAws_restJson1VpcEndpointError = (output, context) => {
    return {
        ErrorCode: __expectString(output.ErrorCode),
        ErrorMessage: __expectString(output.ErrorMessage),
        VpcEndpointId: __expectString(output.VpcEndpointId),
    };
};
const deserializeAws_restJson1VpcEndpointErrorList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1VpcEndpointError(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1VpcEndpoints = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1VpcEndpoint(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1VpcEndpointSummary = (output, context) => {
    return {
        DomainArn: __expectString(output.DomainArn),
        Status: __expectString(output.Status),
        VpcEndpointId: __expectString(output.VpcEndpointId),
        VpcEndpointOwner: __expectString(output.VpcEndpointOwner),
    };
};
const deserializeAws_restJson1VpcEndpointSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1VpcEndpointSummary(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ZoneAwarenessConfig = (output, context) => {
    return {
        AvailabilityZoneCount: __expectInt32(output.AvailabilityZoneCount),
    };
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBody = (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
    }
    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
